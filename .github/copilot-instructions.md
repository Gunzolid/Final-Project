## Project snapshot

- Flutter app (lib/) with pages in `lib/pages`, services in `lib/services`, and data models in `lib/models`.
- Firebase is a first-class integration: `firebase_core`, `cloud_firestore`, `firebase_auth`, `cloud_functions` are in `pubspec.yaml` and runtime config is in `lib/firebase_options.dart` (generated by FlutterFire CLI).
- Cloud Functions live in `functions/` (V2 APIs) and include scripts in `functions/package.json` (serve, shell, deploy).

## Primary responsibilities for an AI coding agent

- Preserve existing Firebase data-shape and collection names: `users` and `parking_spots` are used across the app and functions.
- Keep client <-> backend contracts stable: callable function `recommendAndHold` and triggers `onSpotTaken` / `syncAuthEmailToFirestoreOnUpdate` are used by the app and tests.
- When changing auth/role behavior, update both client signin flow (`lib/main.dart` AuthChecker + `lib/services/user_bootstrap.dart`) and any Cloud Function logic that assumes roles.

## Key files and patterns (use these as authoritative sources)

- App entry: `lib/main.dart` — initializes Firebase, watches `themeNotifier` (in `lib/services/theme_manager.dart`), and decides start page in `AuthChecker`.
- User initialization: `lib/services/user_bootstrap.dart` — ensures `users/{uid}` doc exists; it intentionally does NOT set `role` (defaults to user).
- UI pages: `lib/pages/*` — screen components (e.g., `login_page.dart`, `home_page.dart`, `admin_parking_page.dart`). Use them as canonical screen wiring.
- Models: `lib/models/*` — data shapes for parking spots, layouts, and directions. Prefer these for types and serialization format.
- Firebase client config: `lib/firebase_options.dart` — generated; if you need to change projects, regenerate with FlutterFire CLI instead of hand-editing.
- Cloud Functions: `functions/index.js` and `functions/package.json` — V2 functions, use `npm run serve` for local emulation and `npm run deploy` to deploy functions.

## Typical developer workflows (commands that matter here)

- Local app run: ensure dependencies then run on a device/emulator

  flutter pub get
  flutter run -d <deviceId>

- Android build (CI or local Windows): use Gradle wrapper in `android/` (e.g., `android\\gradlew.bat assembleDebug`).
- Cloud Functions local test/serve/deploy (from repository root):

  cd functions
  npm install
  npm run serve    # runs firebase emulators for functions
  npm run deploy   # deploy only functions

- Tests: one widget test exists in `test/widget_test.dart`. Use `flutter test` for running test suite.

## Project-specific conventions and gotchas

- Theme management: app uses a global `ValueNotifier<ThemeMode>` (`lib/services/theme_manager.dart`). Change theme by updating `themeNotifier.value` rather than rebuilding MaterialApp manually.
- Auth + role resolution: `AuthChecker` in `lib/main.dart` first checks `FirebaseAuth.instance.currentUser`. If null it returns `HomePage` (non-authenticated flow). When present it calls `UserBootstrap.ensureUserDoc()` then reads `users/{uid}.role` to decide admin vs user. Any change to user document shape or role semantics requires updating this flow.
- UserBootstrap intentionally does not write a `role` field. Adding `role` defaults or auto-promotions must be coordinated with Cloud Functions and any admin UI.
- Firestore assumptions: `parking_spots` documents hold fields like `status`, `hold_by`, `hold_until`, and `id`. Cloud Functions use queries and transactions on these fields — keep field names stable.

## Integration pointers

- Firebase config and credentials: `lib/firebase_options.dart` is checked into the repo (client keys). If switching Firebase projects, regenerate with FlutterFire CLI and update configuration in both app and any CI steps.
- Cloud Functions and client communication: functions expose a callable `recommendAndHold` and Firestore triggers; changes to function signatures must be mirrored in client calls.

## When changing this codebase

- If you add Firestore fields or change collection names, search for usages in both `lib/` and `functions/` and update them together.
- If adding new cloud functions, add npm script tests (or eslint rules) to `functions/package.json` and include a short README in `functions/` explaining local emulation (`npm run serve`).

## Where to look first for common tasks

- Add a page/screen: `lib/pages/` and update routing / start logic in `lib/main.dart`.
- Add a new model: `lib/models/` and prefer typed serialization in model classes.
- Modify auth or role behavior: `lib/services/user_bootstrap.dart`, `lib/main.dart` (AuthChecker), and check `functions/index.js` for server-side invariants.

If anything above is unclear or you want the agent to follow stricter rules (naming, tests, commit message format), tell me and I will iterate this file. 
